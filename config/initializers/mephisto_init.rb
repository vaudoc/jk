# this is for standard library loading and configurationg.  All the hardcore monkey patching is in the mephisto plugin.
require 'tzinfo'
require 'zip/zipfilesystem'
require 'action_controller/dispatcher'
require 'coderay'
require 'ruby_pants'
require 'xmlrpc_patch'

ActiveRecord::Base.observers = [:article_observer, :comment_observer]

class ActionController::Dispatcher
  def self.register_liquid_tags
    Mephisto.liquid_filters.each { |mod| Liquid::Template.register_filter mod }
    Mephisto.liquid_tags.each { |name, klass| Liquid::Template.register_tag name, klass }
  end
  
  def cleanup_application_with_plugins(force = false)
    returning cleanup_application_without_plugins(force) do
      self.class.register_liquid_tags
    end
  end
  
  alias_method_chain :cleanup_application, :plugins
end

module Liquid
  AllowedVariableCharacters = /[a-zA-Z_.-]/ unless Liquid.const_defined?(:AllowedVariableCharacters)
end

ActionController::Dispatcher.register_liquid_tags

WhiteListHelper.tags.merge %w(table tr td)

ActiveSupport::CoreExtensions::Time::Conversions::DATE_FORMATS.update \
  :standard  => '%B %d, %Y @ %I:%M %p',
  :stub      => '%B %d',
  :time_only => '%I:%M %p',
  :plain     => '%B %d %I:%M %p',
  :mdy       => '%B %d, %Y',
  :my        => '%B %Y'

class MissingTemplateError < StandardError
  attr_reader :template_type, :templates
  def initialize(template_type, templates)
    @template_type = template_type
    @templates     = templates
    super "No template found for #{template_type}, checked #{templates.to_sentence}."
  end
end

class MissingThemesError < StandardError
  attr_reader :site
  def initialize(site)
    @site = site
    super "No themes found in '#{site.theme_path.to_s}/#{site.current_theme_path}'.  This must be set correctly in the site settings."
  end
end

class ThemeError < StandardError
  attr_reader :theme
  def initialize(theme, message)
    @theme = theme
    super message
  end
end

class Time
  class << self
    # Used for getting multifield attributes like those generated by a 
    # select_datetime into a new Time object. For example if you have 
    # following <tt>params={:meetup=>{:"time(1i)=>..."}}</tt> just do 
    # following:
    #
    # <tt>Time.parse_from_attributes(params[:meetup], :time)</tt>
    def parse_from_attributes(attrs, field, method=:gm)
      attrs = attrs.keys.sort.grep(/^#{field.to_s}\(.+\)$/).map { |k| attrs[k] }
      attrs.any? ? Time.send(method, *attrs) : nil
    end

    def delta(year, month = nil, day = nil)
      from = Time.local(year, month || 1, day || 1)
      
      to = 
        if !day.blank?
          from.advance :days => 1
        elsif !month.blank?
          from.advance :months => 1
        else
          from.advance :years => 1
        end
      return [from.midnight, to.midnight-1]
    end
  end

  def to_delta(delta_type = :day)
    case delta_type
      when :year then self.class.delta(year)
      when :month then self.class.delta(year, month)
      else self.class.delta(year, month, day)
    end
  end
end

class Object
  def tap
    yield self; self;
  end
end